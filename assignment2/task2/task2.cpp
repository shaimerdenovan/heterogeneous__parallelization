/*Задача 2. Работа с массивами и OpenMP
Практическое задание
Реализуйте программу на C++, которая:
1. Создаёт массив из 10 000 случайных чисел.
2. Находит минимальное и максимальное значения массива:
-в последовательной реализации;
-с использованием OpenMP для параллельной обработки.
3. Сравнивает время выполнения обеих реализаций и формулирует выводы.*/
/*подключаем библиотеку для ввода и вывода*/
#include <iostream>
/*библиотека для работы с динамическими массивами*/
#include <vector>
/*библиотека для генерации случайных чисел через srand, rand*/
#include <cstdlib>
/*библиотека для работы с временем (для srand и time)*/
#include <ctime>
/*библиотека OpenMP для параллельных вычислений*/
#include <omp.h>
/*библиотека для стандартных алгоритмов, например swap*/
#include <algorithm>

/*главная функция программы*/
int main() {
    /*создаем константу N - размер массива*/
    const int N = 10000;
    /*создаем вектор arr размера N*/
    std::vector<int> arr(N);
    /*инициализация генератора случайных чисел текущим временем*/
    srand(time(0));
    /*заполняем массив случайными числами от 0 до 99999*/
    for (int i = 0; i < N; i++) {
        arr[i] = rand() % 100000;
    }

    /*последовательная реализация*/
    /*замер времени начала последовательного поиска min и max*/
    double start = omp_get_wtime();
    /*инициализируем min и max первым элементом массива*/
    int min_val = arr[0];
    int max_val = arr[0];
    /*проходим по массиву начиная со второго элемента*/
    for (int i = 1; i < N; i++) {
        /*если текущий элемент меньше min_val, обновляем min_val*/
        if (arr[i] < min_val) min_val = arr[i];
        /*если текущий элемент больше max_val, обновляем max_val*/
        if (arr[i] > max_val) max_val = arr[i];
    }
    /*замер времени окончания последовательного поиска min и max*/
    double end = omp_get_wtime();
    /*выводим минимальное, максимальное значение и время работы последовательного алгоритма*/
    std::cout << "Sequential minimum is " << min_val << ", maximum is " << max_val << ", time is " << end - start << "s\n";

    /*параллельная реализация с OpenMP*/
    /*замер времени начала параллельного поиска min и max*/
    start = omp_get_wtime();
    /*инициализация min и max для параллельного варианта*/
    int min_val_p = arr[0];
    int max_val_p = arr[0];
    /*параллельный цикл с редукцией -минимальное значение*/
    /*и максимальное значение вычисляются всеми потоками одновременно*/
    #pragma omp parallel for reduction(min:min_val_p) reduction(max:max_val_p)
    for (int i = 0; i < N; i++) {
        /*если текущий элемент меньше min_val_p, обновляем min_val_p*/
        if (arr[i] < min_val_p) min_val_p = arr[i];
        /*если текущий элемент больше max_val_p, обновляем max_val_p*/
        if (arr[i] > max_val_p) max_val_p = arr[i];
    }
    /*замер времени окончания параллельного поиска min и max*/
    end = omp_get_wtime();
    /*выводим минимальное, максимальное значение и время работы параллельного алгоритма*/
    std::cout << "Parallel minimum is " << min_val_p << ", maximum is " << max_val_p << ", time is " << end - start << "s\n";

    /*завершение программы*/
    return 0;
}