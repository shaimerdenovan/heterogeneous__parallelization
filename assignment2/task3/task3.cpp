/*Задача 3. Параллельная сортировка с OpenMP
Практическое задание
Реализуйте алгоритм сортировки выбором с использованием OpenMP:
-напишите последовательную реализацию алгоритма;
-добавьте параллелизм с помощью директив OpenMP;
-проверьте производительность для массивов размером 1 000 и 10 000 элементов.*/
/*подключаем библиотеку для ввода и вывода*/
#include <iostream>
/*библиотека для работы с динамическими массивами*/
#include <vector>
/*библиотека для генерации случайных чисел через srand, rand*/
#include <cstdlib>
/*библиотека для работы с временем*/
#include <ctime>
/*библиотека OpenMP для параллельных вычислений*/
#include <omp.h>

/*функция последовательной сортировки выбором*/
void selection_sort(std::vector<int>& arr) {
    /*размер массива*/
    int n = arr.size();
    /*внешний цикл по элементам массива*/
    for (int i = 0; i < n - 1; i++) {
        /*инициализация индекса минимального элемента*/
        int min_idx = i;
        /*внутренний цикл для поиска минимального элемента в остатке массива*/
        for (int j = i + 1; j < n; j++) {
            /*если текущий элемент меньше найденного минимума, обновляем индекс*/
            if (arr[j] < arr[min_idx]) min_idx = j;
        }
        /*меняем местами текущий элемент и найденный минимум*/
        std::swap(arr[i], arr[min_idx]);
    }
}

/*функция параллельной сортировки выбором с OpenMP*/
void parallel_selection_sort(std::vector<int>& arr) {
    /*размер массива*/
    int n = arr.size();
    /*внешний цикл по элементам массива*/
    for (int i = 0; i < n - 1; i++) {
        /*инициализация индекса минимального элемента*/
        int min_idx = i;
        /*начало параллельного блока OpenMP*/
        #pragma omp parallel
        {
            /*локальная переменная минимального элемента для каждого потока*/
            int local_min_idx = i;
            /*параллельный цикл по оставшимся элементам массива*/
            #pragma omp for nowait
            for (int j = i + 1; j < n; j++) {
                /*если текущий элемент меньше локального минимума потока, обновляем его*/
                if (arr[j] < arr[local_min_idx]) local_min_idx = j;
            }
            /*критическая секция для обновления глобального минимального индекса*/
            #pragma omp critical
            {
                if (arr[local_min_idx] < arr[min_idx]) min_idx = local_min_idx;
            }
        }
        /*меняем местами текущий элемент и найденный минимальный элемент*/
        std::swap(arr[i], arr[min_idx]);
    }
}

/*главная функция программы*/
int main() {
    /*массив размеров для тестирования (1000 и 10000 элементов)*/
    const int sizes[] = {1000, 10000};
    /*цикл по всем размерам массивов*/
    for (int s = 0; s < 2; s++) {
        /*текущий размер массива*/
        int N = sizes[s];
        /*создаем вектор массива*/
        std::vector<int> arr(N);
        /*инициализация генератора случайных чисел текущим временем*/
        srand(time(0));
        /*заполнение массива случайными числами от 0 до 9999*/
        for (int i = 0; i < N; i++) arr[i] = rand() % 10000;

        /*создаем копию массива для параллельной сортировки*/
        auto arr_copy = arr;

        /*последовательная сортировка*/
        /*замер времени начала последовательной сортировки*/
        double start = omp_get_wtime();
        /*вызов функции последовательной сортировки выбором*/
        selection_sort(arr);
        /*замер времени окончания последовательной сортировки*/
        double end = omp_get_wtime();
        /*вывод времени работы последовательной сортировки*/
        std::cout << "Sequential sort N=" << N << " time: " << end - start << "s\n";

        /*параллельная сортировка*/
        /*замер времени начала параллельной сортировки*/
        start = omp_get_wtime();
        /*вызов функции параллельной сортировки выбором*/
        parallel_selection_sort(arr_copy);
        /*замер времени окончания параллельной сортировки*/
        end = omp_get_wtime();
        /*вывод времени работы параллельной сортировки*/
        std::cout << "Parallel sort N=" << N << " time: " << end - start << "s\n";
    }
    /*завершение программы*/
    return 0;
}