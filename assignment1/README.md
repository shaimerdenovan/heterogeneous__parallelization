## Описание
Assignment 1 посвящён изучению основ языка C++ и принципов параллельных вычислений. Во время работы над заданиями были реализованы программы с динамическими массивами, выполнены последовательные и параллельные вычисления и было проведено сравнение времени выполнения алгоритмов с использованием OpenMP.
## Структура
В данной папке находятся следующие работы:
- task1 - в данном задании было выполнено динамическое выделение массива и вычисление среднего значения
- task2 - в данном задании был выполнен последовательный поиск минимального и максимального элементов
- task3 - выполнен параллельный поиск минимума и максимума с использованием OpenMP
- task4 - выполнено последовательное и параллельное вычисление среднего значения с редукцией OpenMP

## Задание 1
В первом задании была создана программа, в которой динамически выделяется массив из 50 000 целых чисел. Далее массив заполняется случайными значениями в диапазоне от 1 до 100 и потом вычисляется среднее значение его элементов. В конце, по завершении работы программы выделенная память освобождается.
### Результаты
При запуске программы среднее значение получается около 50 (на скрине можно увидеть что среднее значение 50.6163), что является ожидаемым результатом для заданного диапазона случайных чисел.
## Задание 2
Во втором задании был был создан массив из 1 000 000 целых чисел. Для выполнения задания был реализован последовательный поиск минимального и максимального элементов и дальше измерено время выполнения данного алгоритма.
### Результаты
При запуске программы минимальное значение массива = 1, максимальное =100, данный поиск выполняется быстро (на скрине можно увидеть что время выполнения 0.0041496 секунд).
## Задание 3
В третьем задании был выполнен параллельный вариант поиска минимального и максимального элементов массива с использованием OpenMP. Результаты работы программы были сравнены с последовательным вариантом из предыдущего задания.
### Результаты
На скрине можно увидеть, что параллельная версия программы работает быстрее (время выполнения 0.0024734 секунд), чем последовательная (0.0041496 секунд), так как обработка массива выполняется сразу в нескольких потоках. 
## Задание 4
В четвертом задании был создан массив из 5 000 000 целых чисел. Среднее значение элементов массива считалось двумя способами - последовательным и параллельным с использованием OpenMP и механизма reduction.
### Результаты
Оба способа дают одинаковое среднее значение. При этом параллельная версия(0.0076427) выполняется быстрее последовательной(0.0128032), это показывает преимущество использования параллельных вычислений.
## Вывод
В ходе работы над Assignment 1 были изучены основы работы с динамическими массивами, выполнено сравнение последовательных и параллельных вычислений. Использование OpenMP позволило ускорить обработку массивов при больших объёмах данных. Полученные результаты показали, что параллельные вычисления эффективны.
## Ответы на контрольные вопросы
1. В чём отличие динамического массива от статического массива в языке C++?

Отличие в том, что у статического массива фиксированный размер который заранее задается, а динамический массив создается во время выполнения программы.

2. Что такое указатель и зачем он используется при работе с динамической памятью?

Указатель это переменная, которая хранит адрес другой переменной у себя в памяти. Указатель используется для доступа к динамически выделенному массиву.

3. Почему важно корректно освобождать память после использования динамических массивов?

Потому что если память не освобождать, возникают утечки памяти, и это может привести
к замедлению работы программы.

4. В чём разница между последовательной и параллельной обработкой массива?

Разница в том, что последовательная обработка выполняется одним потоком, а параллельная выполняется несколькими потоками одновременно.

5. Что делает директива #pragma omp parallel for?

Данная директива распределяет выполнение цикла 'for' между несколькими потоками.

6. Для чего используется механизм reduction в OpenMP?

Механизм reduction используется для корректного объединения частичных результатов полученных в разных потоках.

7. Почему при параллельном вычислении суммы необходимо использовать reduction, а не обычную переменную?

Потому что без reduction несколько потоков могут одновременно изменять одну переменную, а это может привести к ошибкам вычислений.

8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?

Неэффективное распределение работы, маленький объем данных, также параллельная программа может работать медленнее если на создание и управление потоками уходит больше времени, чем на сами вычисления. 
